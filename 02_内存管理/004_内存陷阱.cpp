#include <iostream>
#include <memory>
#include <vector>

//(1)
void noMemoryLeak()
{
    std::unique_ptr<int[]> ptr(new int[100]);
    // 使用智能指针，不需要手动释放内存
}

//(2)
void danglingPointerExample() 
{
    int* ptr = new int(10);
    delete ptr;
    // delete ptr; // 重复释放内存，未定义行为
    // std::cout << *ptr; // 未定义行为，悬空指针
    ptr = nullptr; // 将指针置为 nullptr，避免悬空指针
}

void uninitializedPointerExample()
{
    int *ptr;
    // std::cout << *ptr; // 未定义行为
}

struct AlignedStruct 
{
    char a;
    alignas(8) double b; // 确保 b 按 8 字节对齐
    int c;
};

void noMemoryFragmentationExample()
{
    std::vector<int> vec;
    for (int i = 0; i < 1000; ++i)
    {
        vec.resize(vec.size() + 10); // 使用 vector 自动管理内存
    }
}


//自定义删除器
void customDeleter(int *ptr)
{
    // delete[] ptr; // 错误：应使用 delete
    delete ptr;
}


int main(int argc, char const *argv[])
{
    //1.内存泄漏
    /*问题描述： 内存泄漏是指程序分配的内存没有被正确释放，导致内存占用不断增加，最终可能导致程序崩溃或系统资源耗尽。
      常见原因：(1)忘记释放内存：使用 new 分配内存后忘记使用 delete 释放。(2)异常处理不当：在异常发生时，未正确释放已分配的内存。
      解决方案：(1)使用智能指针：std::unique_ptr 和 std::shared_ptr 可以自动管理内存。(2)RAII：通过类的构造函数分配资源，通过析构函数释放资源。*/
    
    //2.悬空指针
    /*问题描述：悬空指针是指指向已释放内存的指针。当程序释放了一块内存后，如果仍然通过该指针访问这块内存，就会导致悬空指针问题。
      常见原因：忘记释放内存后继续使用指针。(2)异常处理不当：在异常发生时，未正确释放已分配的内存。
      解决方案：(1)释放内存后置空指针：释放内存后将指针置为 nullptr,注意，在 nullptr 指针上调用 delete 是允许的，只是这样没有任何效果。(2)智能指针*/

    //3.双重释放
    /*问题描述：双重释放是指对同一块内存执行了多次释放操作。这会导致内存被释放两次，导致内存泄漏或程序崩溃。
      常见原因：(1)多次调用 delete 或 delete[]：对同一块内存多次调用 delete 或 delete[]。(2)指针管理不当：多个指针指向同一块内存，释放内存后未正确管理指针。
      解决方案：同2*/

    //4.野指针
    /*问题描述：野指针是指指向未分配内存或已释放内存的指针。当程序通过野指针访问内存时，会导致未定义行为。
      常见原因：(1)未初始化指针：声明指针变量后未初始化，导致指针指向不确定的内存地址。(2)释放内存后未置空指针：释放内存后将指针置为 nullptr,注意，在 nullptr 指针上调用 delete 是允许的，只是这样没有任何效果。
      解决方案：检查指针的有效性，确保指针指向分配的内存区域。*/

    //5.缓冲区溢出
    /*问题描述：缓冲区溢出是指程序向缓冲区写入数据时，超出了缓冲区的大小，导致覆盖了相邻内存区域的数据。这会导致程序崩溃或安全漏洞。
      常见原因：(1)数组越界：访问数组时超出数组的大小。(2)字符串操作错误：使用 strcpy、strcat 等函数时，未正确处理字符串长度。
      解决方案：(1)使用标准库容器：std::vector 等容器提供了边界检查的成员函数（如 at()）。(2)使用安全的字符串操作函数，如 strncpy、strncat 等。*/

    //6. 未初始化的指针
    /*问题描述： 未初始化的指针指向未知的内存地址，使用该指针会导致未定义行为。
      常见原因：指针未初始化：指针在使用前未初始化。*/

    //7.内存对齐问题
    /*问题描述：内存对齐问题是指程序在访问内存时，要求内存地址满足特定的对齐要求。如果内存地址不满足对齐要求，会导致程序崩溃或性能下降。
      常见原因：结构体成员的对齐要求：结构体成员的对齐要求可能导致结构体的大小超过成员大小的总和。
      解决方案：(1)使用标准库容器：标准库容器会自动处理内存对齐。(2)使用 alignas 和 alignof：手动控制对齐。*/

    //8.内存碎片
    /*问题描述： 内存碎片是指内存中存在大量小块的可用内存，但没有足够的连续内存块来分配大对象，导致内存分配失败。
      常见原因：(1)频繁分配和释放内存：频繁分配和释放不同大小的内存块。(2)内存池管理不当：内存池管理不当导致碎片化。
      解决方案：(1)使用内存池：使用内存池管理内存，减少碎片化。(2)使用标准库容器：标准库容器会自动管理内存，减少碎片化。*/

    return 0;
}
